# Initial Access


Hey, welcome to one of the most exciting parts of red teaming: getting that first foothold. 

Initial Access maps to **MITRE ATT&CK TA0001** and represents **the most fragile stage of any attack**.

You can have:
- Perfect lateral movement
- Beautiful post-exploitation tradecraft
- Zero OPSEC mistakes later on  

…but if **initial access fails**, nothing else matters.

This chapter is about **getting code onto a system and executed**, *without* the user, email gateway, browser, AV, SmartScreen, or EDR stopping you first.


## Why Initial Access Matters So Much

Most blue teams have strong perimeter defenses (email gateways, web proxies, EDR on endpoints), but once something executes on a user machine, things get much harder for them. That's why adversaries layer techniques, make detection expensive in time and effort.

Common real-world paths (2024–2025 trends):

- Phishing (still ~90% of breaches)
- Exploiting public-facing apps (Log4Shell-style, but rarer now)
- Supply-chain compromise (SolarWinds style, very advanced)
- Watering-hole attacks or drive-by downloads

For most red team engagements, especially against mid-to-large orgs, you'll spend the majority of your time perfecting phishing chains.

In modern enterprise environments, **phishing dominates** because:
- Humans are still the weakest control
- Email and browsers are complex trust systems
- Business workflows depend on speed, not suspicion

## Phishing Taxonomy – DELIVERY(CONTAINER(TRIGGER + PAYLOAD + DECOY))

This model from [Mariusz Banach](https://github.com/mgeeky) is brilliant for thinking about chains systematically.

- **Delivery**: How the package reaches the victim (email attachment, link to HTML smuggling page, USB drop, etc.)
- **Container**: The wrapper/format (ISO, ZIP, RAR, LNK inside VHD, etc.)
- **Trigger**: What the user actually double-clicks or interacts with (.lnk, .bat, .msc, macro-enabled doc)
- **Payload**: The evil thing that runs (shellcode, EXE, reflective DLL, Cobalt Strike beacon stager, etc.)
- **Decoy**: The legitimate-looking file that opens after execution (PDF report, Excel sheet, image)


Real example from [Lumma Stealer campaigns](https://www.cloudflare.com/en-in/cloudforce-one/research/loot-load-repeat-dissecting-the-lumma-stealer-playbook/) (very common stealer in 2024–2025):

- Delivery: Phishing email with archive
- Container: ZIP → LNK disguised as PDF
- Trigger: Double-click LNK
- Payload chain: LNK → mshta → obfuscated JS → PowerShell → final stealer EXE
- Decoy: Opens fake PDF after delay

The more layers, the harder for AV/EDR/Sandbox to follow without detonating fully.


## Payload & Decoy: The Trust Continuity Rule

One simple rule that beginners break constantly:

> **Your decoy must reinforce your trigger.**

Examples:
- Trigger looks like PDF → decoy must be a PDF
- Trigger is Excel-related → decoy must open Excel
- Trigger is an installer → decoy should look like setup progress

Mismatch = suspicion.


### DLL Side-Loading & AppDomainManager (.NET Hijack)

In simple terms, DLL side-loading abuses **Windows DLL search order**.

Simplified order:

1. Application directory
2. System32
3. Windows
4. Current working directory
5. PATH directories

If an app tries to load `missing.dll` …and you place `missing.dll` in a writable directory earlier in the search order → **your DLL loads**.

### Why This Still Works

- Old versions of binaries still exist
- WinSxS keeps historical builds
- Some binaries don’t use secure loading flags

Key idea:

> You don’t need a vulnerable app — you need a *careless* one.


### AppDomainManager Hijacking (.NET-Specific but Powerful)

For .NET Framework apps:

- You can force-load a DLL **before application logic**
- No need to hijack DLL search order

Mechanisms:

- Environment variables
- App config files

Why this is powerful:

- Code runs early
- Happens inside legitimate .NET apps
- Less obvious than classic injection

In Short:

- Create DLL inheriting AppDomainManager
- Override InitializeNewDomain() or put evil in constructor
- Set env vars: APPDOMAIN_MANAGER_ASM + APPDOMAIN_MANAGER_TYPE
- Or use .exe.config file with same settings
- Copy vulnerable .NET exe + your DLL to same folder → run exe

I've used this in engagements where users run legacy internal tools. Very quiet, inherits process context.


### Windows Installer (MSI)

MSIs are fantastic containers/triggers:

- Can drop files anywhere (even Program Files if you social-engineer admin)
- Custom actions to run payload during "install"
- Looks legitimate ("Setup.exe" or "Update.msi")

Steps in Visual Studio:

1. New Setup Project
2. Add payload file → set properties (hidden, rename)
3. Custom Actions → Install → Add Custom Action → point to payload
4. Set Run64Bit=true for 64-bit payloads
5. Build → deliver .msi (ignore wrapper .exe)

Edge case: Modern Windows blocks MSI from internet (MotW + Protected View). Use container that strips MotW (more later).

Defender reality:

> Users trust installers more than executables.


### Excel Add-Ins (.xlam)

Great for macro execution without opening document directly.

Excel add-ins:

- Auto-load from trusted directories
- Execute without user interaction
- Blend into normal Excel behaviour

Key trick:

- `%APPDATA%\Microsoft\Excel\XLSTART` is writable
- Excel loads everything there automatically

This bypasses:

- Macro warnings
- Protected View (if MotW is avoided)

**Important**

> Excel add-ins work a bit differently from normal Excel files, and that’s exactly why they’re so effective. An `.xlam` file isn’t treated like a document you open, it’s treated like an extension that Excel _loads_ to add features. Excel has a special startup folder (`%APPDATA%\Microsoft\Excel\XLSTART`) that it checks every time it launches, and anything placed there is automatically loaded without asking the user. Since this folder is writable by a normal user, an attacker only needs to copy the add-in there once. From that point on, the next time Excel opens — whether the user clicks a spreadsheet or just launches Excel normally,  the add-in loads silently and its macro code runs as part of Excel’s normal startup. Because this isn’t a document being opened, Excel doesn’t show the usual macro warning banners or Protected View prompts, assuming the add-in was intentionally installed by the user. If Mark of the Web is avoided earlier in the chain, this becomes a very clean and reliable way to execute code while blending in with completely normal Excel behaviour.



### Code Signing Considerations

Signed binaries = fewer SmartScreen warnings, sometimes less AV scrutiny.

- **Standard** cert: Just signature
- **EV** cert: Removes "Unknown Publisher" completely (gold standard)

Real adversaries:

- Buy EV via shell companies
- Use leaked/stolen certs (search GitHub leaks, forums)
- Never use your real company cert, easy revocation

In engagements: Always test both signed + unsigned chains. Many orgs still allow unsigned if user clicks through.


## Droppers (Why One File Is Rarely Enough)

In simple words:

> A dropper is a program whose job is to deliver another program.


Why droppers exist:
- AV evasion
- Payload separation
- Analysis resistance

Learn more about **[GadgetToJScript](https://github.com/med0x2e/GadgetToJScript)** tool and a short writeup here at: https://maximilian-marx.me/posts/malware-obfuscation/


## Triggers – (The Click That Matters)

Goal: Double-click → payload runs, decoy opens, user happy.

### Batch (.bat / .cmd)

Simple but noisy.

Trick to evade sandbox: Check %cmdcmdline% vs %~f0 → only run evil if double-clicked.

```batch
@echo off
echo %cmdcmdline% | find /i "%~f0" || exit
start payload.exe
start decoy.pdf
exit
```

### Shell Link (.lnk)

Most deceptive, hide .lnk extension, fake icon, custom args.

PowerShell creation example (from CRTO course):

```
$wsh = New-Object -ComObject WScript.Shell
$lnk = $wsh.CreateShortcut("report.pdf.lnk")
$lnk.TargetPath = "%COMSPEC%"
$lnk.Arguments = "/C start payload.exe && start decoy.pdf"
$lnk.IconLocation = "C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe,13"
$lnk.Save()
```

### MSC Files (High-Risk, High-Reward)

Uses XSS in MMC to run VBS/JS.

Weaponized line (URL-encoded VBS):

```
<xsl:script ...> wshshell.run "cmd.exe" </xsl:script>
```

Dangerous because:

- MMC is trusted
- Often overlooked
- Can lead to high-integrity execution

## Delivery: Getting Past the Front Door

Perimeter security is **front-heavy**:
- Email gateways
- URL filtering
- Proxies
- Reputation engines

So attackers avoid:
- Direct downloads
- Obvious MIME types
- Static payload hosting

### HTML Smuggling

Encode payload in HTML/JS → browser decodes & downloads on click.

- File content embedded in HTML
- JavaScript reconstructs file locally
- No binary download observed

From the gateway’s view:

> “It's Just HTML and JavaScript.” 

This bypasses:
- File-type scanning
- MIME-based detection

This is a sample template based on work by [Stan Hegt](https://x.com/stanhacked).

```html
<html>
    <head>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/brands.min.css">
    </head>
    <body>
        <button class="btn" onclick="downloadFile()"><i class="fa fa-download"></i> Download</button>

        <script>
            function convertFromBase64(base64) {
                let binary_string = window.atob(base64);
                let len = binary_string.length;
                let bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function downloadFile() {
                const file = 'VGhpcyBpcyBhIHNtdWdnbGVkIGZpbGU=';
                const fileName = 'test.txt';
                let data = convertFromBase64(file);
                let blob = new Blob([data], {type: 'octet/stream'});
                if (window.navigator.msSaveOrOpenBlob) {
                    window.navigator.msSaveBlob(blob,fileName);
                }
                else {
                    const a = document.createElement('a');
                    document.body.appendChild(a);
                    a.style = 'display: none';
                    const url = window.URL.createObjectURL(blob);
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    window.URL.revokeObjectURL(url);
                }
            }
        </script>
    </body>
</html>
```


 In above code, The file is base64-encoded and stored in the `file` variable, so its content is already present in the victim's browser when the page loads. Clicking the button triggers the `downloadFile` JavaScript function, which decodes the data, creates a Blob, generates a temporary URL, and automatically initiates the download. The file is then saved to the user’s default Downloads folder.

From the perspective of gateways or proxies, only HTML and JavaScript are visible, no binary content or `application/octet-stream` MIME type is transmitted, unlike traditional file downloads. 

Base64 is a basic encoding method; more advanced evasion is possible by encrypting the payload with the Web Crypto API (e.g., AES) and heavily obfuscating the JavaScript.

### SVG Smuggling

Similar, but .svg file with `<script>` tag.

Very dangerous because:

- SVG looks like an image
- Browsers trust it
- Script execution surprises users

### Cobalt Strike Site Clone + Hosted File

Clone real page (e.g., GPU-Z download) → embed hidden iframe to auto-download your payload.

Steps:

1. Host File in CS (set URI, lookalike domain)
2. Clone Site → point to real URL, Attack = hosted file
3. Send clone URL → user visits → auto-download

**Works because iframe src triggers download without click.**



