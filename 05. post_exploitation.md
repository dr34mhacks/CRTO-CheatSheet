
# ðŸ§  Post-Exploitation: Where Operations Are Won or Lost


If **initial access** is breaking into the building, **post-exploitation** is everything that happens **after youâ€™re inside**.

Post-exploitation is where a red team engagement actually _becomes meaningful_. Getting a Beacon on a system is only an entry ticket; the real work begins when you start **moving toward the operational objective**. At this stage, the goal is no longer â€œcan I run commands,â€ but rather _can I quietly understand this environment well enough to take it over without alerting anyone_.

This phase answers the real questions:

- ðŸŽ¯ _Where is the objective?_
- ðŸ‘¤ _Who has access to it?_    
- ðŸ”‘ _How do I become that person, **quietly?**_

## Situational Awareness: Learning Before Acting


One of the biggest mistakes most people make is immediately jumping into aggressive actions such as credential dumping or mass network scanning. Seasoned operators slow down first. This pause is intentional and critical.

Situational awareness is about understanding **what kind of machine you are on** and **what kind of environment you are inside**. Every environment has its own rules, security posture, and operational patterns. Acting without understanding them is how detections happen.

At this stage, you are trying to form a mental model of the system: how it is used, who uses it, and how locked down it is. You are not looking for exploits yet, you are looking for _context_.

This typically involves discovering whether the machine holds interesting files or mapped drives, whether sensitive software or administrative tools are installed, what defensive products are present, which users are logged in, and how hardened the system is through policies such as UAC or SMB signing. At a broader level, you also want to understand how this machine fits into the domain: what other systems exist, what services they run, and which users have access to them.

Cobalt Strike provides a wide range of built-in primitives for doing this safely, but using them correctly requires understanding **how each command behaves internally**.

## Why Command Behaviour Matters

Not all Beacon commands are equal from a detection standpoint. Two commands might return similar information but operate in completely different ways under the hood. One might quietly call a Windows API, while another might spawn a process, inject code, and leave forensic artifacts behind.

An experienced operator does not think in terms of _what command gives me the answer_, but rather _what is the least risky way to obtain this information in this environment_.

This is why understanding command behaviour is foundational to safe post-exploitation.

### House-Keeping Commands : Adjusting the Beacon, Not the System

House-keeping commands exist to control Beacon itself rather than the target system. Commands such as `sleep`, `spawnto`, `ppid`, and `jobs` modify runtime settings stored inside Beaconâ€™s memory.

These commands are operationally safe because they do not execute payloads, inject code, or touch the operating system in a meaningful way. They are used to tune Beaconâ€™s behavior, for example, slowing down check-ins, changing the default process used for fork-and-run actions, or reviewing long-running background jobs.

| Command   | Purpose                                                                   |
| --------- | ------------------------------------------------------------------------- |
| `sleep`   | Adjusts check-in interval (set check-in delay)                            |
| `spawnto` | Sets default process for fork & run like rundll32.exe for opsec           |
| `ppid`    | Spoofs parent process why? Mimics legit trees, fools parent-child hunting |
| `jobs`    | Lists long-running tasks                                                  |

From a defensive perspective, these commands are essentially invisible, which is why operators often adjust Beacon configuration early in post-exploitation.

These are **safe to run early** and often should be.

```
beacon> sleep 30
```

> ðŸ§  Slowing down Beacon before enumeration often reduces network noise immediately.

###  API-Only Commands : Your First Choice


API-only commands execute **inside Beacon** and rely only on Windows APIs.

They are:

- Low noise
- Low risk
- High value

| Command               | What it tells you         |
| --------------------- | ------------------------- |
| `pwd`                 | Current working directory |
| `ls`                  | Directory contents        |
| `cd`                  | Change context            |
| `ps`                  | Running processes         |
| `upload` / `download` | File transfer             |
| `rm`, `mv`, `cp`      | File manipulation         |

Example: File System Recon

```
beacon> pwd
[*] Current directory is C:\Users\dr34mhacks\Desktop
```

This immediately tells you:

- Which user you are
- What permissions you likely have
- Why future commands might fail

###  Inline Execution (BOFs) :  Stealth with Fragility


BOFs (Beacon Object Files) are small C programs executed **inside Beacon memory** using `inline-execute`.

### Why BOFs Exist

- No new process
- No injection
- Smaller detection surface

**Important**

> If the code inside the BOF crashes, then the Beacon will die along with it.


Examples: `dllload` (load DLL in Beacon), `getsystem` (impersonate SYSTEM, relates to priv esc), `timestomp` (alter file timestamps for anti-forensics).

> Its timestomp (and I swear I haven't made typo) 


### ðŸ§ª Fork & Run : Stable but Louder


Fork & run uses a **temporary or existing process** and injects a reflective DLL.

**Two Variant**

| Variant      | Description                      | Example                                                                                |
| ------------ | -------------------------------- | -------------------------------------------------------------------------------------- |
| **spawn**    | Creates a new temp process       | `execute-assembly` for .NET, `powerpick` for PS without powershell.exe for AMSI bypass |
| **explicit** | Injects into an existing process | `psinject` for PS in remote proc, `mimikatz` for cred dump                             |

Some commands (like `mimikatz`, `portscan`) support **both**.

We can identify support via `help`.

```
beacon> help execute-assembly
Use: execute-assembly [/path/to/file.exe] [arguments]  << spawn
```

```
beacon> help psinject
Use: psinject [pid] [arch] [commandlet] [arguments]    << explicit
```

```
beacon> help mimikatz
Use: mimikatz [pid] [arch] [module::command] <args>    << explicit
     mimikatz [module::command] <args>                 << spawn
```

Simple rule:

> If the command syntax acceptsÂ `[arch]`Â andÂ `[pid]`Â arguments, then it's 'explicit', otherwise it's 'spawn'.


### ðŸ” Session Passing - Changing Channels Mid-Op

Sometimes you want:

- ðŸ¢ DNS Beacon for persistence
- ðŸš€ HTTP Beacon for interaction

Thatâ€™s session passing.

Basically, Spawn new Beacons from old ones - switch listeners (e.g., **slow DNS** to **fast HTTP**) without re-exploiting.
#### `spawn` -  Same User, New Listener

```
beacon> spawn x64 http
```

Creates a new Beacon:

- Same user
- Same privileges
- Different C2 channel

#### `spawnas` -  New User, New Session

(as name says spawn **as**)

```
beacon> spawnas HACKME\hacker Passw0rd123! http
```

Caveats:

- Often fails in SYSTEM context
- Depends heavily on Windows API behavior

##### Common Failure: Error 267

```
ERROR_DIRECTORY
```

Cause:

- Beaconâ€™s working directory isnâ€™t accessible by the new user

Fix:

```
beacon> cd C:\
beacon> spawnas HACKME\hacker Passw0rd123! http
```

ðŸ§  This is Windows permissions,  not a Cobalt Strike issue. You can have the session in a directory where you has already access (recall those oscp moment as a user sid you have access to `/home/sid` but not at `/home/dev`)


### ðŸ“‚ File System Commands (Core Enumeration)

These are **API-only or near-API-only commands** and should usually be your **first choice** during post-exploitation.

| Command     | Purpose                        | Execution Behaviour    | When to Use             | Operator Notes                   |
| ----------- | ------------------------------ | ---------------------- | ----------------------- | -------------------------------- |
| `pwd`       | Show current working directory | API-only               | Always run early        | Explains permission issues later |
| `ls`        | List directory contents        | API-only               | File & user recon       | Prefer over `shell dir`          |
| `ls <path>` | List specific directory        | API-only               | Targeted browsing       | Absolute & relative paths work   |
| `cd <path>` | Change working directory       | API-only               | Fix permission issues   | Critical before `spawnas`        |
| `drives`    | List available drives          | API-only               | Check for extra volumes | Look for mounted shares          |
| `upload`    | Upload file to target          | API-only               | Payload staging         | Use legit-looking paths          |
| `download`  | Download file from target      | API-only (C2 transfer) | Looting configs / creds | Speed depends on Beacon channel  |
| `rm`        | Delete file                    | API-only               | Cleanup                 | Always clean up artifacts        |
| `mv`        | Move/rename file               | API-only               | Masquerading            | Rename payloads early            |
| `cp`        | Copy file                      | API-only               | Backup or staging       | Useful before modification       |

ðŸ§  **Rule of thumb**  

> If you can answer your question using `ls`, `ps`, or `reg` ; **donâ€™t escalate to shell or PowerShell**.



### ðŸ“‹ Clipboard Command (High ROI)

Clipboard access is one of the **highest signal-to-noise** techniques in post-exploitation.

| Command     | Purpose             | Execution Behaviour | When to Use                  | Operator Notes                |
| ----------- | ------------------- | ------------------- | ---------------------------- | ----------------------------- |
| `clipboard` | Read text clipboard | API-only            | Any interactive user session | Users copy secrets constantly |

```
beacon> clipboard
Clipboard Data (22 bytes):
MySup3rS3cr3tPassw0rd123!
```

ðŸ§  Notes:

- No injection
- No process creation
- Often yields passwords, API keys, MFA codes
- Clears nothing, purely read-only

### ðŸ§¬ Registry Commands (Local Recon Goldmine)

Registry enumeration tells you **how hardened the system is** and **why things behave the way they do**.

| Command      | Purpose               | Execution Behaviour | When to Use      | Operator Notes              |
| ------------ | --------------------- | ------------------- | ---------------- | --------------------------- |
| `reg query`  | List keys & values    | API-only            | Policy discovery | Use for UAC, LAPS, Defender |
| `reg queryv` | Read specific value   | API-only            | Precise checks   | Faster, less noisy          |
| `x86 / x64`  | Registry view control | API-only            | WOW64 systems    | Avoid missing values        |
Example (UAC posture):

```
beacon> reg query x64 HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System
```

ðŸ§  Common uses:

- UAC behavior
- Credential protections
- Security feature toggles
- Persistence verification

### ðŸ–¥ï¸ Screenshot & Screen Monitoring Commands


These commands **inject code**, use them carefully.

**Screenshot-Related Commands**

| Command       | Behaviour                 | Best Use Case       | OPSEC Notes         |
| ------------- | ------------------------- | ------------------- | ------------------- |
| `printscreen` | Clipboard-based injection | Quick one-off view  | Clears clipboard âš ï¸ |
| `screenshot`  | Injects DLL, grabs screen | Safer snapshot      | No clipboard abuse  |
| `screenwatch` | Continuous screenshots    | Observe active user | Tied to sleep time  |

ðŸ§  `screenwatch` frequency:

- `sleep 5` â†’ every 5 seconds
- `sleep 60` â†’ every minute
    
All screenshots appear in **View â†’ Screenshots**.


### ðŸ–±ï¸ VNC (Desktop Control)

This is **high-impact, high-risk** but extremely powerful.

| Command   | Purpose           | Execution Behaviour           | When to Use        | Operator Notes       |
| --------- | ----------------- | ----------------------------- | ------------------ | -------------------- |
| `desktop` | Remote GUI access | Reflective DLL + port forward | User impersonation | View-only by default |
```
beacon> desktop high
```

ðŸ§  Notes:

- Creates reverse port forward
- Closing the tab tears everything down
- Keyboard/mouse control is optional
- Very visible to the user ðŸ‘€

### ðŸ§ª Execution Commands (`shell` vs `run`)

These execute **external programs**, generally **bad OPSEC**.

| Command | How It Runs      | Best Use            | OPSEC Notes    |
| ------- | ---------------- | ------------------- | -------------- |
| `shell` | `cmd.exe /c`     | Built-in commands   | Spawns cmd.exe |
| `run`   | Direct execution | Standalone binaries | No cmd.exe     |

```
beacon> shell whoami /user
beacon> run whoami /user
```

**Important**

ðŸ§  Prefer:

- `ls` over `dir`
- `getuid` over `whoami`

### âš¡ PowerShell Execution Options (Choose Wisely)

| Command      | Engine         | Injection  | When to Use        | Notes                     |
| ------------ | -------------- | ---------- | ------------------ | ------------------------- |
| `powershell` | powershell.exe | âŒ          | Quick checks       | Equivalent to `shell`     |
| `powerpick`  | Unmanaged PS   | âœ… spawn    | EDR-aware ops      | No powershell.exe         |
| `psinject`   | Unmanaged PS   | âœ… explicit | Other user context | Requires injection rights |

> ðŸ§  `powerpick` is often the **best default choice** under EDR.


### ðŸ“¦ Importing PowerShell Scripts

| Command             | Purpose        | Notes                |
| ------------------- | -------------- | -------------------- |
| `powershell-import` | Load PS script | One script at a time |

```
beacon> powershell-import PowerView.ps1
beacon> powerpick Get-Domain
```

> ðŸ§  Beacon hosts the script on an internal webserver and loads it in memory.


### ðŸ§± .NET Execution (`execute-assembly`)

|Command|Purpose|Execution Model|Notes|
|---|---|---|---|
|`execute-assembly`|Run .NET Framework EXE|Fork & run + CLR|No .NET Core|

```
beacon> execute-assembly Seatbelt.exe AntiVirus
```

ðŸ§  Common tools:

- Seatbelt
- Rubeus
- Certify
- SharpHound (older)

### ðŸ§© BOFs (Inline Execution)

| Command          | Purpose | Risk              | Notes              |
| ---------------- | ------- | ----------------- | ------------------ |
| `inline-execute` | Run BOF | Beacon crash risk | Extremely stealthy |

Often wrapped via aliases:

```
beacon> ipconfig
```

ðŸ§  BOFs are **elite-tier tooling** small, fast, quiet.


