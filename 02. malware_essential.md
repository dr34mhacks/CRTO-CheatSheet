# Malware Essentials

Alright, future red teamer, welcome to the gritty world of malware basics! This stuff is important because as a red teamer, you'll often need to craft custom payloads for initial access or evasion think dropping shellcode into processes without relying on off-the-shelf tools like Cobalt Strike.

This section is one of those **â€œif this clicks, everything else becomes easierâ€** moments in red teaming.

Most people can *use* payloads.  
Fewer people understand *why they work*.  
Very few understand *why they fail in real environments*.


## Why Red Teamers Need Malware Basics

Modern C2 frameworks (like Cobalt Strike) can generate:
- `.exe`
- `.dll`
- `.ps1`
- `.bin` (shellcode)

So the obvious beginner question is:

> â€œWhy not just use the generated payload and move on?â€

Because **initial access, OPSEC, and evasion** often require:

- Custom loaders
- Raw shellcode
- Living-off-the-land execution
- In-memory execution only

If you donâ€™t understand:

- PE structure
- Processes
- Memory
- Threads  

â€¦then **process injection will feel like magic** instead of engineering.


## PE File Structure (What Windows Actually Loads)

A **Portable Executable (PE)** is the format Windows understands.  

Both `.exe` and `.dll` are PEs.

Think of a PE as:

> ðŸ“¦ A structured container telling Windows *how* and *where* to load code.


### DOS Header (Yes, DOS Still Exists Here)

Every PE starts with a **64-byte DOS header**.

Two fields matter:

#### `e_magic`
- Value: `4D 5A` â†’ `"MZ"`
- Purpose: Marks the file as executable
- If this is wrong â†’ Windows wonâ€™t load it

#### `e_lfanew`
- Offset to the **NT headers**
- Always located at offset `0x3C`
- Windows uses this to *skip old DOS junk*

Mental model:

> â€œJump from fake DOS land to real Windows land.â€


Imagine a PE as a house: Headers are the foundation, sections are the rooms with code and data.

- **DOS Header**: Starts every PE, 64 bytes fixed. Key parts: 'MZ' magic bytes (0x4D5A) to say "Hey, I'm a PE!" and e_lfanew (at offset 0x3C) pointing to the real NT headers. It's legacy stuff from DOS days, but Windows skips it.
    
- **DOS Stub**: Right after the header, it's junk code that prints "Can't run in DOS" if you try old-school. Modern loaders ignore it via e_lfanew.
    
- **NT Headers**: The meat. There's a 32-bit and 64-bit version (IMAGE_NT_HEADERS or _64). Starts with 'PE\0\0' signature.
    
    - **File Header (IMAGE_FILE_HEADER)**: Tells CPU type (e.g., x86 vs. x64), section count, optional header size, and characteristics (like if it's an exe or dll).
    - **Optional Header**: Not really optional! Despite the name, this header is **mandatory**. Has magic for 32/64-bit, entry point RVA (relative virtual address, where code starts running), preferred image base (e.g., 0x400000 for exes), and data directories array.
      
- **Data Directories**: Array of pointers to special info, like imports (DLLs needed) or exports. Each has a virtual address and size.
    
- **Sections**: Where the action is, code and data live here. Common ones: .text (executable code), .data (initialized vars), .bss (uninitialized), .rdata (read-only), .rsrc (icons, strings). Each has a header with name, virtual size/address (in mem), raw size (on diskâ€”padded), and characteristics (permissions like RX for code).

Common sections:

| Section  | Purpose                 |
| -------- | ----------------------- |
| `.text`  | Executable code         |
| `.data`  | Initialized variables   |
| `.bss`   | Uninitialized data      |
| `.rdata` | Read-only data          |
| `.rsrc`  | Icons, strings, dialogs |

Each section has **permissions**:
- R
- RW
- RX

Red team takeaway:

> Executable memory (`RX`, `RWX`) is suspicious and heavily monitored.

I know you get nothing out of it so learn from the best:

- https://youtu.be/l6GjU8fm8sM
- https://youtu.be/GqhTfNvFtww
- https://youtu.be/SzOhG-aUUJs


## Process Injection Techniques

A **program** is a file.  
A **process** is a *running instance* of that file.

Important ideas:

- Same EXE â†’ multiple processes
- Each process has:
  - Virtual memory
  - Handles
  - Threads
  - Security token
### Process Creation APIs (What Red Teamers Care About)

- `CreateProcessW` â†’ same token
- `CreateProcessAsUserW` â†’ different token
- `CreateProcessWithLogonW` â†’ plaintext creds

Eventually:

> All roads lead to `NtCreateUserProcess`

Why this matters:
- EDR hooks high-level APIs
- Native APIs are harder to monitor cleanly

## Privileges (Silent Power)

Some privileges are **game-ending**:

- `SeDebugPrivilege` â†’ read/write any process
- `SeTakeOwnershipPrivilege` â†’ take control of objects
- `SeRestorePrivilege` â†’ overwrite files
- `SeLoadDriverPrivilege` â†’ kernel code
- `SeCreateTokenPrivilege` â†’ forge identities

Important:

> Privileges must be **enabled**, not just present.


