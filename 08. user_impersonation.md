

## Becoming Someone Else ðŸ•µï¸â€â™‚ï¸

> Token impersonation is one of those techniques that feels _too powerful_ the first time you use it, because it often is. Instead of cracking passwords or dumping LSASS, you temporarily **borrow the identity of another user** and let Windows authenticate you naturally.

### ðŸ§  Mental Model (Very Important)

Think of tokens like **ID cards issued by Windows**:

- You donâ€™t â€œbecomeâ€ the user
- You **act on their behalf**
- Some doors care about _network identity_
- Some doors care about _local identity_

This distinction explains _everything_ below.

### Two Main Ways in Beacon

- **make_token** â†’ Create new token using **plaintext credentials** (LogonUser API)
- **steal_token** â†’ Steal existing token from another running process (DuplicateToken + ImpersonateLoggedOnUser)


| Technique     | How token is obtained  | Local actions | Network actions | Integrity required |
| ------------- | ---------------------- | ------------- | --------------- | ------------------ |
| `make_token`  | Plaintext credentials  | âŒ No          | âœ… Yes           | âŒ No (Medium)      |
| `steal_token` | Existing process token | âœ… Yes         | âœ… Yes           | âœ… Yes (High)       |


#### ðŸ”‘ `make_token` â€” Credential-Based Impersonation

`make_token` creates a **netonly logon token** using plaintext credentials.  

Under the hood, Beacon uses APIs like:
- `LogonUserA`
- `ImpersonateLoggedOnUser`

**Example:**

```
beacon> make_token HACKME\sid Passw0rd123!
[+] Impersonated HACKME\sid (netonly)
```

##### What â€œnetonlyâ€ actually means ðŸ§ 

- Windows **does not create a full interactive logon**
- No local profile is loaded
- No local group memberships are applied
- Only **network authentication** uses the impersonated identity

This is why the CRTO notes correctly state:

> _This allows Beacon to use the alternate credentials when interacting with resources on the network. It has no impact on local actions._


**When this shines** âœ¨

- Accessing SMB shares
- Authenticating to SQL servers
- LDAP queries
- WinRM / HTTP-based services

**When this fails** âŒ

- Local admin actions 
- Injecting into processes owned by that user
- Accessing local protected files
    
**Key advantage**

- No high-integrity needed
- Very low noise
- Perfect after browser / DPAPI credential theft


#### ðŸ•µï¸ `steal_token` â€” Process-Based Impersonation


`steal_token` is much more powerful because it **duplicates a real token from a live process**.

##### What actually happens internally

Beacon performs the following steps:

1. `OpenProcess` â€” get handle to target process
2. `OpenProcessToken` â€” extract its primary token
3. `DuplicateToken` â€” convert to impersonation token
4. `ImpersonateLoggedOnUser` â€” switch Beaconâ€™s thread token

> Thatâ€™s why **high-integrity is required**: opening another userâ€™s token is privileged.


**Identifying a Target Process**

```
beacon> ps

 PID   Name     User
 5247  cmd.exe  HACKME\adminsid
```

**Stealing the Token**

```
beacon> steal_token 5247
[+] Impersonated HACKME\adminsid
```

> Now Beacon behaves **locally and remotely** as `adminsid`.


### Why this is powerful ðŸ’¥

- Local file access now applies
- Network access applies
- Privileges embedded in token apply
- You can inject into _other processes owned by that user_

> This is how red teamers quietly move laterally **without credentials**.



#### ðŸ”„ `rev2self` â€” Dropping Impersonation Cleanly

At any point, you may want to return to your original context.


```
beacon> rev2self

# This calls RevertToSelf()
```


> Always revert when done. Staying impersonated longer than needed increases blast radius if you make a mistake.


#### ðŸ§  Token Lifetime Problem (and the Fix)

Hereâ€™s a subtle but **very real operational issue**:

> If you steal a token from a process, and that process exits, you lose the token.

Why?  

Because tokens are **reference-counted by the kernel**.  
Once the last handle closes, the token is destroyed.

#### ðŸ¦ `token-store` â€” Persistent Token Handling

Beacon solves this with a **token store**.

**Steal and Store a Token**

```
beacon> token-store steal 5247
```

**View Stored Tokens**

```
beacon> token-store show

 ID   PID   User
 0    5247  HACKME\adminsid

```

**Reuse Token Anytime**

```
beacon> token-store use 0
[+] Impersonated HACKME\adminsid
```

**Remove When Done**

```
beacon> token-store remove 0
```


#### ðŸŽ¯ Choosing the Right Technique (Operator Decision Table)

| Scenario                       | Best Choice   | Reason              |
| ------------------------------ | ------------- | ------------------- |
| Have plaintext creds           | `make_token`  | No elevation needed |
| Need local access              | `steal_token` | Full token required |
| Want low OPSEC risk            | `make_token`  | No process touching |
| Lateral movement without creds | `steal_token` | Token reuse         |
| Long-term identity reuse       | `token-store` | Persistence         |


#### ðŸš¨ OPSEC Notes (Read This)

- `make_token` is extremely quiet â€” **no LSASS**, no injection
- `steal_token` requires process access â€” **EDR may log OpenProcess**
- Token impersonation blends in far better than:
    - `runas`
    - `psexec`
    - explicit credential use

> Used properly, token impersonation looks like **normal Windows behavior**, because it _is_.


# ðŸ”‘ Pass-the-Hash (PtH) - Borrowing Passwords Without Knowing Them

Pass-the-Hash is a classic Windows post-exploitation technique that allows an attacker to **authenticate as a user without ever knowing their plaintext password**. Instead of cracking the password, you directly reuse the **NTLM hash** as proof of identity.

Historically, this worked extremely well because:

- NTLM was everywhere
- Password reuse was rampant
- Windows trusted hashes almost as much as passwords
    
That landscape is changing â€” but PtH is **not dead yet**.

### Core Concept (Simple Explanation)

- NTLM hash = one-way MD4 hash of the Unicode password (e.g., "Passw0rd!" â†’ `fc525c9683e8fe067095ba2ddc971889`)
- Windows accepts this hash directly for NTLM authentication (SMB, WMI, WinRM, etc.)
- Two main flavors:
    1. **Raw NTLM** (Impacket style) â†’ network protocols
    2. **In-memory injection** (Mimikatz style) â†’ patches hash into local logon session

**Beacon's built-in method** uses Mimikatz's `sekurlsa::pth` â€” injects hash into a new logon session, then runs a command as that user.

**Beacon PtH Command**

```
beacon> pth [DOMAIN\user] [NTLM hash]
```

**Example:**

```
beacon> pth HACKME\sid fc525c9683e8fe067095ba2ddc971889
```


#### ðŸ” What Actually Happens Internally

Beacon performs a clever trick to make Windows accept the hash:

1. Mimikatz opens **LSASS with write access**
2. The NTLM hash is **patched into the MSV1_0 credential structure**
3. A fake process (`cmd.exe`) is launched
4. That process writes random data to a **named pipe**
5. Beacon impersonates the token associated with that pipe

**Typical Output**

```
[*] Tasked beacon to run mimikatz's sekurlsa::pth /user:"sid" /domain:"HACKME" /ntlm:fc525c9683e8fe067095ba2ddc971889 /run:"%COMSPEC% /c echo 8d3f86487c1 > \\.\pipe\f08610"

user    : sid
domain  : HACKME
program : C:\Windows\system32\cmd.exe /c echo 8d3f86487c1 > \\.\pipe\f08610
impers. : no
NTLM    : fc525c9683e8fe067095ba2ddc971889
  |  PID  2920
  |  TID  3716
  |  LSA Process is now R/W
  |  LUID 0 ; 18729858 (00000000:011dcb82)
  \_ msv1_0   - data copy @ 000001F7FB8EA9D0 : OK !
  \_ kerberos - data copy @ 000001F7FB8FCD28
   \_ des_cbc_md4       -> null             
   \_ des_cbc_md4       OK
   ... (multiple OKs for Kerberos keys)
   \_ *Password replace @ 000001F7FB8D77A8 (32) -> null
```


#### OPSEC Reality Check

Beaconâ€™s PtH has **serious OPSEC implications**:

#### Why itâ€™s noisy ðŸ”Š

- LSASS memory is modified
- Kernel callbacks may fire
- EDRs love detecting `sekurlsa::pth`
- Write access to LSASS is rarely benign
    

Compared to:

- Token impersonation
- Kerberos tickets
- DPAPI credential reuse
    
ðŸ‘‰ **PtH is the loudest option**


### ðŸŽŸï¸ Pass the Ticket (PtT) : Impersonation Without Touching LSASS

Pass-the-Ticket is the **Kerberos-native evolution** of Pass-the-Hash.  

Instead of reusing password material (hashes), you reuse **Kerberos tickets themselves**, the _actual proof of authentication_ in modern Windows environments.

From a defenderâ€™s perspective, PtT looks far more legitimate than PtH:

- Kerberos is the default protocol
- Tickets are meant to be cached and reused
- No NTLM fallback required
- No LSASS patching required

> This is why PtT is generally considered **superior, stealthier, and more future-proof**.


##### ðŸ§  Mental Model First (Very Important)

Kerberos works on **tickets**, not passwords.

- Passwords / hashes are used **only to request tickets**
- Once you have a ticket, **passwords are irrelevant**
- Windows happily uses cached tickets without re-authentication

So PtT is simply:

> â€œI already have valid proof -  let me please reuse it.â€


##### ðŸŽ« Requesting a TGT (Legitimate Kerberos Flow)

Tickets donâ€™t have to be stolen  they can be **requested legitimately** if you possess:

- AES keys (preferred)
- NTLM hash (returns RC4 tickets, discouraged)

##### Why AES Matters

- Modern domains prefer AES128 / AES256
- RC4 tickets stand out in logs
- AES aligns with default domain behavior

**Requesting a TGT with Rubeus**

```
beacon> execute-assembly Rubeus.exe asktgt /user:sid /domain:HACKME.COM /aes256:<aes256-key> /nowrap
```

What happens here:

- Rubeus builds a normal AS-REQ
- KDC responds with a valid TGT
- Ticket is returned as base64 (`.kirbi` format)

> This is **not exploitation**, it is normal Kerberos usage with stolen key material.


But Wait...

#### The Ticket Clobbering Problem

> When you inject a Kerberos TGT into an **existing logon session**, you are not â€œaddingâ€ a ticket - you are **replacing the identity material** Windows already relies on for that session.

A **logon session (LUID)** is Windowsâ€™ container for:

- Kerberos tickets
- Authentication state
- Network identity

If your Beacon is currently running as `HACKME\sid`, that logon session already contains:

- A TGT for `sid`
- Possibly multiple service tickets (LDAP, CIFS, etc.)

When you inject a TGT for `adminsid` into that same session:

- Windows discards `sid`â€™ tickets
- The session now â€œbelongsâ€ to `adminsid` from Kerberosâ€™ perspective
- `sid` suddenly loses access to domain resources
    
This is **not subtle**.  
The real user may experience:

- Broken SMB connections
- Failed LDAP queries
- Authentication prompts
- Application crashes
    
From a blue-team point of view, this looks like:

> â€œWhy did this userâ€™s Kerberos identity suddenly change mid-session?â€

That is why this mistake is **high-risk OPSEC-wise** and extremely common among beginners.


##### âœ… Correct Strategy: New Logon Session

To avoid clobbering:

1. Create a **new logon session**
2. Inject tickets there
3. Use that session only for your actions

**Step 1 : Create a NetOnly Session**

```
beacon> make_token HACKME\adminsid FakePass
```

**Why the Fake Password Works**

- `/netonly` explicitly tells Windows:
    
> â€œDo not validate these credentials locally or with the DCâ€
    
- The password is never checked 
- No Kerberos exchange occurs
- No tickets are issued
    
**What you get is:**

- A **blank logon session**
- Zero Kerberos tickets
- Safe isolation from real users

If you ran `klist` at this point, you would see:

- No TGT
- No service tickets
    
This is exactly what we want.

**Step 2 : Injecting the Ticket into That Session**

```
beacon> kerberos_ticket_use C:\Users\Attacker\Desktop\adminsid.kirbi
```

Now something important happens:

- The ticket is added to **the new LUID**
- The original userâ€™s session is untouched
- Windows believes this session legitimately authenticated
    
At this moment:

- Any Kerberos-authenticated request uses `adminsid`
- LDAP, SMB, CIFS, HTTP â€” all work as `adminsid`
- No user disruption
- No NTLM fallback
- No LSASS tampering
    
This is **textbook clean PtT**.

**Cleanup**

Two different cleanup actions exist - and they do **different things**:

| Command                 | What it affects                                  |
| ----------------------- | ------------------------------------------------ |
| `kerberos_ticket_purge` | Clears tickets **but keeps the session**         |
| `rev2self`              | Destroys impersonation **and exits the session** |

Why this matters:

- You may want to **keep the session alive** but rotate tickets (`kerberos_ticket_purge`)
- Or fully revert to your original context (`rev2self`)

Knowing the difference prevents accidental loss of access.


### ðŸ”§ The Rubeus Way (More Flexible)


**Create a NetOnly Process**

```
beacon> execute-assembly Rubeus.exe createnetonly /program:notepad.exe /username:adminsid /domain:HACKME.COM /password:FakePass
```

This returns:

- PID
- LUID

This process is now a **clean container** for tickets.


**Inject Ticket Directly (Base64 Supported)**

```
beacon> execute-assembly Rubeus.exe ptt /luid:<LUID> /ticket:<base64>
```

Advantages:

- Inject TGTs _and_ service tickets
- No disk artifacts needed
- More precise control

**Using the Ticket (Important Step)**

> Even after injection, Beacon is not automatically using that identity.

You must:

```
beacon> steal_token <PID>
```

This impersonates the process tied to the ticket cache.

By the way something important:

#### The `getuid` / `steal_token` Confusion

You gonna panic when you see:

```
[+] Impersonated HACKME\sid
```

instead of `adminsid`.

This is **expected behavior**.

ðŸ§  Why:

- `getuid` reflects the **primary token**
- Kerberos tickets live in the **logon session**
- Identity â‰  ticket ownership
    
What matters is:

> **Kerberos authentication now uses adminsidâ€™s tickets**

Not the displayed username.


## ðŸ§¨ Process Injection as Impersonation 

Another way to â€œbecomeâ€ a user is to **inject Beacon directly into their process**.

`beacon> inject 5247 x64 http`

Result:

- New Beacon runs inside target process
- Inherits full security context
- No ticket juggling required
    
Downsides:

- Requires high integrity
- Louder
- Harder to clean up


### ðŸ§  Choosing the Right Technique

|Situation|Best Option|
|---|---|
|Want stealth|PtT|
|Avoid LSASS|PtT|
|Have AES keys|PtT|
|Only NTLM hash|PtH (fallback)|
|Need instant access|Process injection|

> So PtT >>> PtH >> Process Injection (Opsec way)

